(window.webpackJsonp=window.webpackJsonp||[]).push([[129],{475:function(e,v,_){"use strict";_.r(v);var V=_(42),t=Object(V.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h2",{attrs:{id:"_1-mvvm-的概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-mvvm-的概念"}},[e._v("#")]),e._v(" 1. MVVM 的概念")]),e._v(" "),_("blockquote",[_("p",[e._v("Mvvm 定义 MVVM 是 Model-View-ViewModel 的简写。是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于 2005 年在他的博客上发表。即模型-视图-视图模型。")])]),e._v(" "),_("p",[e._v("一句话总结 Web 前端 MVVM：操作数据，就是操作视图，就是操作 DOM（所以无须操作 DOM ）。无须操作 DOM ！借助 MVVM 框架，开发者只需完成包含 声明绑定 的视图模板，编写 "),_("code",[e._v("ViewModel")]),e._v(" 中业务数据变更逻辑，View 层则完全实现了自动化。这将极大的降低前端应用的操作复杂度、极大提升应用的开发效率。MVVM 最标志性的特性就是 数据绑定 ，MVVM 的核心理念就是通过 声明式的数据绑定 来实现 View 层和其他层的分离。完全解耦 View 层这种理念，也使得 Web 前端的单元测试用例编写变得更容易。")]),e._v(" "),_("h3",{attrs:{id:"分层架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分层架构"}},[e._v("#")]),e._v(" 分层架构")]),e._v(" "),_("ul",[_("li",[e._v("Model: 域模型，用于持久化")]),e._v(" "),_("li",[e._v("View: 作为视图模板存在")]),e._v(" "),_("li",[e._v("ViewModel: 作为视图的模型，为视图服务")])]),e._v(" "),_("h4",{attrs:{id:"model-层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#model-层"}},[e._v("#")]),e._v(" Model 层")]),e._v(" "),_("p",[e._v("Model 层，对应数据层的域模型，它主要做域模型的同步。通过 "),_("code",[e._v("Ajax/fetch")]),e._v(" 等 API 完成客户端和服务端业务 Model 的同步。在层间关系里，它主要用于抽象出 "),_("code",[e._v("ViewModel")]),e._v(" 中视图的 "),_("code",[e._v("Model")]),e._v("。")]),e._v(" "),_("h4",{attrs:{id:"view-层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#view-层"}},[e._v("#")]),e._v(" View 层")]),e._v(" "),_("p",[e._v("View 层，作为视图模板存在，在 MVVM 里，整个 View 是一个动态模板。除了定义结构、布局外，它展示的是 "),_("code",[e._v("ViewModel")]),e._v(" 层的数据和状态。View 层不负责处理状态，View 层做的是 数据绑定的声明、 指令的声明、 事件绑定的声明。")]),e._v(" "),_("h4",{attrs:{id:"viewmodel-层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#viewmodel-层"}},[e._v("#")]),e._v(" ViewModel 层")]),e._v(" "),_("p",[_("code",[e._v("ViewModel")]),e._v(" 层把 View 需要的层数据暴露，并对 "),_("code",[e._v("View")]),e._v(" 层的 数据绑定声明、 指令声明、 事件绑定声明 负责，也就是处理 View 层的具体业务逻辑。"),_("code",[e._v("ViewModel")]),e._v(" 底层会做好绑定属性的监听。当 "),_("code",[e._v("ViewModel")]),e._v(" 中数据变化，View 层会得到更新；而当 "),_("code",[e._v("View")]),e._v(" 中声明了数据的双向绑定（通常是表单元素），框架也会监听 View 层（表单）值的变化。一旦值变化，"),_("code",[e._v("View")]),e._v(" 层绑定的 "),_("code",[e._v("ViewModel")]),e._v(" 中的数据也会得到自动更新。")]),e._v(" "),_("h2",{attrs:{id:"_2-mvvm-图解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-mvvm-图解"}},[e._v("#")]),e._v(" 2. MVVM 图解")]),e._v(" "),_("img",{attrs:{src:e.$withBase("/MVVM.png"),alt:"mvvm"}}),e._v(" "),_("p",[e._v("如图所示，在前端 MVVM 框架中，往往没有清晰、独立的 "),_("code",[e._v("Model")]),e._v(" 层。在实际业务开发中，我们通常按 "),_("code",[e._v("Web Component")]),e._v(" 规范来组件化的开发应用，Model 层的域模型往往分散在在一个或几个 "),_("code",[e._v("Component")]),e._v(" 的 "),_("code",[e._v("ViewModel")]),e._v(" 层，而 "),_("code",[e._v("ViewModel")]),e._v(" 层也会引入一些 View 层相关的中间状态，目的就是为了更好的为 View 层服务。")]),e._v(" "),_("p",[e._v("开发者在 View 层的视图模板中声明 数据绑定、 事件绑定 后，在 "),_("code",[e._v("ViewModel")]),e._v(" 中进行业务逻辑的 数据 处理。事件触发后，"),_("code",[e._v("ViewModel")]),e._v(" 中 数据 变更， "),_("code",[e._v("View")]),e._v(" 层自动更新。因为 MVVM 框架的引入，开发者只需关注业务逻辑、完成数据抽象、聚焦数据，MVVM 的视图引擎会帮你搞定 "),_("code",[e._v("View")]),e._v("。因为数据驱动，一切变得更加简单。")]),e._v(" "),_("h2",{attrs:{id:"_3-mvvm-框架的工作流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-mvvm-框架的工作流程"}},[e._v("#")]),e._v(" 3. MVVM 框架的工作流程")]),e._v(" "),_("p",[e._v("不可置否，MVVM 框架极大的提升了应用的开发效率。It's amazing！But，MVVM 框架到底做了什么？")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("视图引擎：为 View 层作为视图模板提供强力支持，开发者不需要操作 DOM")])]),e._v(" "),_("li",[_("p",[e._v("数据存取器：可以通过 Object.defineProperty() API 轻松定义，或通过自行封装存取函数的方式曲线完成。我的内部往往封装了 发布/订阅模式，以此来完成对数据的监听、数据变更时通知更新。是数据绑定 实现的基础。")])]),e._v(" "),_("li",[_("p",[e._v("组件机制：按照面向未来的组件标准 － Web Components 的方式开发，MVVM 框架提供组件的定义、继承、生命周期、组件间通信机制，为开发者面向未来开发点亮明灯。")])])]),e._v(" "),_("h2",{attrs:{id:"_4-mvvm-与-mvc-的对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-mvvm-与-mvc-的对比"}},[e._v("#")]),e._v(" 4. MVVM 与 MVC 的对比")]),e._v(" "),_("p",[e._v("认真看过 Vue 文档大概都能注意到，Vue 实例的变量名是 vm，文档中还很严谨地补充了一句 “虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发”。\n按照上面不同的工程师眼里有不同的 MVC 结构的引言，Vue 虽然“没有完全遵循 MVVM 模型”，但是我觉得这就是一种 Vue 特化的 MVVM。")]),e._v(" "),_("h3",{attrs:{id:"vue-的-mvvm"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue-的-mvvm"}},[e._v("#")]),e._v(" Vue 的 MVVM")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("View：单文件里 "),_("code",[e._v("<template>")]),e._v(" 标签的内容，展现给用户的内容，与 ViewModel 双向绑定，可以在其中插入 ViewModel 提供的数据。")])]),e._v(" "),_("li",[_("p",[e._v("ViewModel：Vue 实例整个都是 ViewModel，与 View 双向绑定，用户在 View 修改数据或发出 ajax 等指令时， ViewModel 会及时相应，接着向下修改 Model——至此可以看出 Model 和 View 是没有直接关系的。")])]),e._v(" "),_("li",[_("p",[e._v("Model：这一层或者有歧义。为了更好理解 Model 需要引入 Vuex，在有 Vuex 的情况下，Vuex 提供的数据就是 Model，这符合后端架构中 Model 包含业务逻辑的情况。但是在无 Vuex 的情况下，Model 应该就是 Vue 实例的 data 属性，也就是 JavaScript 数据对象本身。")])])]),e._v(" "),_("h3",{attrs:{id:"前端-mvc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端-mvc"}},[e._v("#")]),e._v(" 前端 MVC")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("View：一样是展现给用户的部分，整个或部分 HTML 页面。")])]),e._v(" "),_("li",[_("p",[e._v("Model：JavaScript 的变量数据（可以包含 ajax 获取数据的逻辑，或是一个数据管理机制），但是在这里要额外地添加提醒 View 更新的机制。几个月前我还迷糊为什么 MVC 也有观察者模式，MVC 的观察者是 View，在 Model 注册为观察者就能在 Model 更新时更新。")])]),e._v(" "),_("li",[_("p",[e._v("Controller：用户操作逻辑放置点，输入是用户的操作，输出是对 Model 的修改。")])])]),e._v(" "),_("h3",{attrs:{id:"两者对比图"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#两者对比图"}},[e._v("#")]),e._v(" 两者对比图")]),e._v(" "),_("img",{attrs:{src:e.$withBase("/mvc和mvvm.png"),alt:"mvc和mvvm"}}),e._v(" "),_("p",[e._v("在理解 MVVM 和 MVC 的区别时我纠结了很久，基于 Vue 来说，感觉非常像 MVC：页面订阅数据；数据更新时页面更新，但是看了这幅图后豁然开朗。")]),e._v(" "),_("p",[e._v("图中对比的是 MVC 和 MVP，但是 MVP 和 MVVM 的区别基本就是 MVVM 把三者间的操作自动绑定了，不用开发者操心 V 和 P 之间的相互操作。\nMVC 是由 M 通知 V，但 MVVM 是 M 通知 VM（M 和 V 没有直接关系）。")])])}),[],!1,null,null,null);v.default=t.exports}}]);