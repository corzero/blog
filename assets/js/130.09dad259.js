(window.webpackJsonp=window.webpackJsonp||[]).push([[130],{476:function(t,_,v){"use strict";v.r(_);var l=v(42),s=Object(l.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"总体过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总体过程"}},[t._v("#")]),t._v(" 总体过程")]),t._v(" "),v("ul",[v("li",[t._v("解析 url")]),t._v(" "),v("li",[t._v("发送 http|https 请求")]),t._v(" "),v("li",[t._v("解析 dom 为 dom 树")]),t._v(" "),v("li",[t._v("解析 css 为 cssom 树")]),t._v(" "),v("li",[t._v("生成 render 树")]),t._v(" "),v("li",[t._v("渲染 layout")]),t._v(" "),v("li",[t._v("绘制 painting")])]),t._v(" "),v("h2",{attrs:{id:"分步理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分步理解"}},[t._v("#")]),t._v(" 分步理解")]),t._v(" "),v("h3",{attrs:{id:"_1-解析-url"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-解析-url"}},[t._v("#")]),t._v(" 1. 解析 url")]),t._v(" "),v("p",[t._v("获取 url 通常是一下方法按序查找")]),t._v(" "),v("ol",[v("li",[t._v("从浏览器中获取 url 对应的 ip（浏览器中是有缓存 dns 的）")]),t._v(" "),v("li",[t._v("从本地电脑 hosts 文件中获取 url 对应的 ip 地址（如果之前访问过）")]),t._v(" "),v("li",[t._v("通过 dns 服务器缓存查找")]),t._v(" "),v("li",[t._v("通过递归类型依次查询根服务、顶级服务、本地服务")])]),t._v(" "),v("h3",{attrs:{id:"_2-发送-http-https-请求"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-发送-http-https-请求"}},[t._v("#")]),t._v(" 2. 发送 http|https 请求")]),t._v(" "),v("p",[t._v("获取到 url 对应的 ip 地址后，浏览器发送 http（https）请求")]),t._v(" "),v("p",[t._v("建立 http 连接需要通过 tcp 三次握手，具体如下")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("第一次握手: 客户端向服务器发出连接请求报文，这时报文首部中的同部位 SYN=1，同时随机生成初始序列号 seq=x，此时，TCP 客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP 规定，SYN 报文段（SYN=1 的报文段）不能携带数据，但需要消耗掉一个序号。这个三次握手中的开始。表示客户端想要和服务端建立连接。")])]),t._v(" "),v("li",[v("p",[t._v("第二次握手: TCP 服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是 ack=x+1，同时也要为自己随机初始化一个序列号 seq=y，此时，TCP 服务器进程进入了 SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。这个报文带有 SYN(建立连接)和 ACK(确认)标志，询问客户端是否准备好。\n第三次握手")])]),t._v(" "),v("li",[v("p",[t._v("第三次握手: TCP 客户进程收到确认后，还要向服务器给出确认。确认报文的 ACK=1，ack=y+1，此时，TCP 连接建立，客户端进入 ESTABLISHED（已建立连接）状态。TCP 规定，ACK 报文段可以携带数据，但是如果不携带数据则不消耗序号。这里客户端表示我已经准备好。")])])]),t._v(" "),v("p",[v("label",{staticStyle:{color:"red"}},[t._v("备注")]),t._v(": 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误,必须要三次握手。https 相比 http 只是在会话层多了一个 tsl（ssl）安全套接字协议")]),t._v(" "),v("h3",{attrs:{id:"_3-获取-html-进行解析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-获取-html-进行解析"}},[t._v("#")]),t._v(" 3. 获取 html 进行解析")]),t._v(" "),v("p",[t._v("html 解析是"),v("label",{staticStyle:{color:"red"}},[t._v("有序渐进式")]),t._v("的。")]),t._v(" "),v("blockquote",[v("p",[t._v("有序渐进式：从第一行开始，一行一行依次解析；渐进式则指得是浏览器会迫不及待的将解析完成的部分显示出来。")])]),t._v(" "),v("p",[v("b",[t._v(" 总体过程如下图所示 ")])]),t._v(" "),v("img",{attrs:{src:t.$withBase("/html渲染.png"),alt:"html渲染"}}),t._v(" "),v("p",[t._v("不难发现浏览器解析 html 大致分为五步：")]),t._v(" "),v("ol",[v("li",[v("b",[t._v("HTML -> DOM 树 （解析 html）")])])]),t._v(" "),v("blockquote",[v("p",[t._v("DOM 全称为文档对象模型 Document Object Model，其中一个 DOM 节点对应一个标签，Dom 树即表示了 HTML 的文档结构。转化过程如下图所示：")])]),t._v(" "),v("blockquote",[v("img",{attrs:{src:t.$withBase("/html解析.png"),alt:"html解析"}})]),t._v(" "),v("ul",[v("li",[v("p",[t._v("解码：浏览器从磁盘或网络读取 HTML 的原始字节，然后根据指定的文件编码格式（例如 UTF-8）将其转换为相应字符")])]),t._v(" "),v("li",[v("p",[t._v('令牌化：浏览器把字符转化成 W3C HTML5 标准指定的各种确切的令牌，比如""、""以及其他在尖括号内的字符串。每个令牌都有特殊的含义以及它自己的一套规则')])]),t._v(" "),v("li",[v("p",[t._v("词法分析：生成的令牌转化为对象，这个对象定义了它们的属性及规则")])]),t._v(" "),v("li",[v("p",[t._v("DOM 树构建：最后，由于 HTML 标记定义了不同标签之间的关系（某些标签嵌套在其他标签中），创建的对象在树状的数据结构中互相链接，树状数据结构也捕获了原始标签定义的父子关系：HTML 对象是 body 对象的父对象，body 是 p 对象的父对象等等")])])]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[v("b",[t._v("CSS → CSSOM 树（解析 CSS 样式）")])])]),t._v(" "),v("p",[t._v("CSSOM 全称为 CSS 对象模型 CSS Object Model，CSSOM 告诉了浏览器元素在渲染时是什么样的。与 HTML 一样，我们需要将收到的 CSS 规则转换为浏览器可以理解、能够处理的东西。因此，我们重复与处理 HTML 非常相似的过程：")]),t._v(" "),v("img",{attrs:{src:t.$withBase("/css解析1.png"),alt:"css解析1"}}),t._v(" "),v("p",[t._v("CSSOM 只输出包含有样式的节点，最终输出为：")]),t._v(" "),v("img",{attrs:{src:t.$withBase("/css解析2.png"),alt:"css解析2"}}),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[v("b",[t._v("生成渲染树 Render Tree （计算可见节点和样式）")])])]),t._v(" "),v("p",[t._v("DOM 描述的是文档结构，CSSOM 描述的是文档的样式规则，构建这颗树的目的是为了以正确的顺序绘制文档内容，渲染树为：")]),t._v(" "),v("img",{attrs:{src:t.$withBase("/生成renderTree.png"),alt:"生成renderTree"}}),t._v(" "),v("p",[t._v("它有下面的特点：")]),t._v(" "),v("ul",[v("li",[t._v("不包括 Header 、 script 、meta 等不可见的节点")]),t._v(" "),v("li",[t._v("某些通过 CSS 隐藏的节点在渲染树中也会被忽略，比如应用了 display:none 规则的节点，而 visibility:hidden 只是视觉不可见，仍占据空间，不会被忽略。")])]),t._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[v("b",[t._v("（渲染）layout")])])]),t._v(" "),v("p",[t._v("依照盒子模型，计算出每个节点在屏幕中的位置及尺寸")]),t._v(" "),v("ol",{attrs:{start:"5"}},[v("li",[v("b",[t._v("（渲染）painting")])])]),t._v(" "),v("p",[t._v("按照算出来的规则，通过显卡，把内容画到屏幕上。")]),t._v(" "),v("h4",{attrs:{id:"重新渲染（拓展）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#重新渲染（拓展）"}},[t._v("#")]),t._v(" 重新渲染（拓展）")]),t._v(" "),v("ol",[v("li",[v("b",[t._v("reflow 重排 （即重新 layout）")])])]),t._v(" "),v("p",[t._v("当可见节点位置及尺寸发生变化时会发生重排，具体为下面情况：")]),t._v(" "),v("p",[t._v("页面初始渲染:")]),t._v(" "),v("ul",[v("li",[t._v("添加/删除可见 DOM 元素")]),t._v(" "),v("li",[t._v("改变元素位置")]),t._v(" "),v("li",[t._v("改变元素尺寸（宽宽、高、内外边距、边框等）")]),t._v(" "),v("li",[t._v("改变元素内容**（文本、html 等）**")]),t._v(" "),v("li",[t._v("改变元素字体大小")]),t._v(" "),v("li",[t._v("改变窗口尺寸")])]),t._v(" "),v("p",[t._v("不会发生重排的行为：")]),t._v(" "),v("ul",[v("li",[t._v("读取 dom 节点属性、内容、样式")])]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[v("b",[t._v("repaint 重绘 （即重新 paint）")])])]),t._v(" "),v("ul",[v("li",[t._v("改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。")])]),t._v(" "),v("p",[t._v("它是一个可见节点改变除位置和大小以外的外观所触发的浏览器行为，有下面几个特点：")]),t._v(" "),v("ul",[v("li",[t._v("重绘不一定导致重排")]),t._v(" "),v("li",[t._v("重排一定会导致重绘，因为重绘是浏览器渲染页面的最后一步")])]),t._v(" "),v("h3",{attrs:{id:"常见问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见问题"}},[t._v("#")]),t._v(" 常见问题")]),t._v(" "),v("p",[t._v("问：浏览器在什么时候向服务器发送获取 css、js 外部文件的请求？")]),t._v(" "),v("p",[t._v("答：解析 DOM 时碰到外部链接，如果还有 connection，则立刻触发下载请求。")]),t._v(" "),v("p",[t._v("问：CSSOM DOM JavaScript 三者阻塞关系？")]),t._v(" "),v("p",[t._v("答：CSSOM DOM 互不影响，JavaScript 会阻塞 DOM 树的构建但 JS 前的 HTML 可以正常解析成 DOM 树， CSSOM 的构建会阻塞 JavaScript 的执行。这也解释了为什么 JavaScript 的执行都需要访问 DOM 和 CSSOM 的能力，却只受 CSSOM 的阻塞。")])])}),[],!1,null,null,null);_.default=s.exports}}]);